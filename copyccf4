#!/bin/bash
# =============================================================================
#  Script:      hcp_copy_to_node.sh
#  Purpose:     Copy HCP objects from any available source node to a target node
#               WITHOUT overwriting existing objects. Supports DRY-RUN.
#
#  Input format (each line in list files):
#       <namespace>/<object-path>
#  Example:
#       my-ns/abcd-1234-L/000000000000abcd.ccf
#
#  What it does per object:
#    1) Check destination: if object exists -> SKIP (never overwrite)
#    2) Find first source node where object exists (HTTP 200/204/206)
#    3) (DRY-RUN) record plan OR (REAL) stream-copy: GET source | PUT dest
#    4) Verify on destination and log verdict
#
#  Safety:
#    - No DELETE is ever issued
#    - No overwrite: destination is checked before any PUT
#
#  Output (under output/<timestamp>_copy_to_<target>/):
#    - copy_summary.tsv            : path | source_node | target_node | result | info
#    - copied.txt                  : successfully copied
#    - skipped_exists.txt          : already present on destination
#    - not_found_on_any_source.txt : present on none of the source nodes
#    - failed.txt                  : copy attempted but object not found on dest after retries
#    - would_copy.txt              : (dry-run) objects that would be copied
#    - objects_union.txt           : deduplicated worklist used in this run
#    - copy.log                    : detailed audit (PROCESS / CHECK DST / CHECK SRC / actions)
#
#  Usage:
#    ./hcp_copy_to_node.sh \
#        --lists "path/to/hcp1.txt path/to/hcp2.txt ..." \
#        --target hcp4 \
#        --nodes  "hcp1 hcp2 hcp3 hcp4" \
#        --tenant YOUR_TENANT \
#        --domain YOUR_DOMAIN \
#        --token  'YOUR_TOKEN' \
#        [--retries 2] [--limit N] [--debug] [--dry-run]
#
#  Notes:
#    - Pass the RAW HCP token (do NOT prefix it with 'Authorization: HCP ')
#    - HTTPS is used with -k (insecure) to tolerate self-signed certs; adjust if needed
# =============================================================================

set -euo pipefail

# ------------------------------- Arguments -----------------------------------
LISTS=""        # space-separated list files (each contains lines: <namespace>/<object-path>)
TARGET=""       # target node alias (e.g., hcp3)
NODES=""        # space-separated node aliases to probe as sources (e.g., "hcp1 hcp2 hcp4")
TENANT=""       # tenant portion used in hostnames
DOMAIN=""       # domain portion used in hostnames
TOKEN=""        # RAW token value (no "Authorization: HCP " prefix)
RETRIES=2       # number of retry attempts on copy (PUT) after the first try
LIMIT=0         # optional: process only the first N objects (0 = no limit)
DEBUG=0         # verbose logging to copy.log
DRYRUN=0        # 1 = plan only, do not PUT

while [[ $# -gt 0 ]]; do
  case "$1" in
    --lists)   LISTS="$2"; shift 2 ;;
    --target)  TARGET="$2"; shift 2 ;;
    --nodes)   NODES="$2";  shift 2 ;;
    --tenant)  TENANT="$2"; shift 2 ;;
    --domain)  DOMAIN="$2"; shift 2 ;;
    --token)   TOKEN="$2";  shift 2 ;;
    --retries) RETRIES="$2"; shift 2 ;;
    --limit)   LIMIT="$2";   shift 2 ;;
    --debug)   DEBUG=1; shift ;;
    --dry-run) DRYRUN=1; shift ;;
    -h|--help)
      cat <<EOF
Usage:
  $0 --lists "hcp1.txt hcp2.txt ..." --target hcpX --nodes "hcp1 hcp2 ..." \\
     --tenant TENANT --domain DOMAIN --token TOKEN [--retries N] [--limit N] [--debug] [--dry-run]
EOF
      exit 0 ;;
    *) echo "Unknown arg: $1" >&2; exit 1 ;;
  esac
done

# Required args
[[ -n "${LISTS}" && -n "${TARGET}" && -n "${NODES}" && -n "${TENANT}" && -n "${DOMAIN}" && -n "${TOKEN}" ]] \
  || { echo "ERROR: required args missing"; exit 1; }

# Validate list files
for f in $LISTS; do
  [[ -f "$f" ]] || { echo "ERROR: list file not found: $f" >&2; exit 1; }
done

# ----------------------------- Output structure ------------------------------
STAMP="$(date +%Y%m%d_%H%M%S)"
OUTDIR="output/${STAMP}_copy_to_${TARGET}"
mkdir -p "${OUTDIR}"

LOG="${OUTDIR}/copy.log"
TSV="${OUTDIR}/copy_summary.tsv"
UNION="${OUTDIR}/objects_union.txt"

COPIED="${OUTDIR}/copied.txt"
SKIPPED_EXISTS="${OUTDIR}/skipped_exists.txt"
NOT_FOUND_SRC="${OUTDIR}/not_found_on_any_source.txt"
FAILED="${OUTDIR}/failed.txt"
WOULD_COPY="${OUTDIR}/would_copy.txt"  # dry-run only

: > "${LOG}"; : > "${TSV}"; : > "${UNION}"
: > "${COPIED}"; : > "${SKIPPED_EXISTS}"; : > "${NOT_FOUND_SRC}"; : > "${FAILED}"; : > "${WOULD_COPY}"
echo -e "path\tsource_node\ttarget_node\tresult\tinfo" > "${TSV}"

# --------------------------------- Helpers -----------------------------------
clean_line() { echo "$1" | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'; }

log() { printf "[%s] %s\n" "$(date '+%F %T')" "$*" >> "${LOG}"; }

http_code() {
  # Return HTTP code for a GET probe (no body)
  local url="$1"
  curl -sk -o /dev/null -w '%{http_code}' -H "Authorization: HCP ${TOKEN}" "${url}" || echo "000"
}

exists_on_node() {
  # True if code is 200/204/206
  local url="$1" code
  code="$(http_code "$url")"
  [[ "$code" =~ ^(200|204|206)$ ]]
}

copy_stream() {
  # Stream: GET source | PUT destination; outputs the PUT HTTP code
  local src_url="$1" dst_url="$2"
  curl -sk -H "Authorization: HCP ${TOKEN}" "${src_url}" \
  | curl -sk -X PUT \
      -H "Authorization: HCP ${TOKEN}" \
      -H "Content-Type: application/octet-stream" \
      --data-binary @- -o /dev/null -w '%{http_code}' "${dst_url}" || echo "000"
}

# ------------------------------ Build union list -----------------------------
# Merge all lines from list files, normalize spacing, remove duplicates.
for f in $LISTS; do awk 'NF' "$f"; done \
 | sed -e 's/\r$//' -e 's/^[[:space:]]*//;s/[[:space:]]*$//' \
 | awk '!seen[$0]++' > "${UNION}"

TOTAL="$(wc -l < "${UNION}" | tr -d ' ')"
log "Union built: ${TOTAL} unique objects"
(( DEBUG )) && { echo "Lists: ${LISTS}" >> "${LOG}"; echo "Target: ${TARGET}" >> "${LOG}"; }

# --------------------------------- Main loop ---------------------------------
i=0
while IFS= read -r raw || [[ -n "$raw" ]]; do
  LINE="$(clean_line "$raw")"
  [[ -z "${LINE}" ]] && continue
  (( i++ ))
  (( LIMIT > 0 && i > LIMIT )) && { log "Limit ${LIMIT} reached. Stopping."; break; }

  log "PROCESS: ${LINE}"

  # Parse namespace and key
  NS="${LINE%%/*}"
  KEY="${LINE#*/}"

  # Destination probe (never overwrite)
  DST_URL="https://${NS}.${TENANT}.${TARGET}.${DOMAIN}/rest/${KEY}"
  dst_code="$(http_code "${DST_URL}")"
  log "CHECK DST: ${TARGET} code=${dst_code} url=${DST_URL}"

  if [[ "${dst_code}" =~ ^(200|204|206)$ ]]; then
    echo "${LINE}" >> "${SKIPPED_EXISTS}"
    echo -e "${LINE}\t-\t${TARGET}\tskip-exists\t${dst_code}" >> "${TSV}"
    log "SKIP: already exists on ${TARGET}"
    continue
  fi

  # Find first source node with the object
  SRC_NODE=""; SRC_URL=""
  for n in ${NODES}; do
    [[ "${n}" == "${TARGET}" ]] && continue
    url="https://${NS}.${TENANT}.${n}.${DOMAIN}/rest/${KEY}"
    src_code="$(http_code "${url}")"
    log "CHECK SRC: ${n} code=${src_code} url=${url}"
    if [[ "${src_code}" =~ ^(200|204|206)$ ]]; then
      SRC_NODE="${n}"; SRC_URL="${url}"
      break
    fi
  done

  if [[ -z "${SRC_NODE}" ]]; then
    echo "${LINE}" >> "${NOT_FOUND_SRC}"
    echo -e "${LINE}\t-\t${TARGET}\tno-source\t404" >> "${TSV}"
    log "NO-SOURCE: not found on any source node"
    continue
  fi

  # Dry-run: record plan only
  if (( DRYRUN )); then
    echo "${LINE}" >> "${WOULD_COPY}"
    echo -e "${LINE}\t${SRC_NODE}\t${TARGET}\tdry-run\twould-copy" >> "${TSV}"
    log "DRY-RUN would copy: ${SRC_NODE} -> ${TARGET}"
    continue
  fi

  # Real copy with retries (first attempt + RETRIES)
  attempt=0; put_code="000"
  while (( attempt <= RETRIES )); do
    (( attempt++ ))
    log "COPY attempt ${attempt}: ${SRC_NODE} -> ${TARGET}"
    put_code="$(copy_stream "${SRC_URL}" "${DST_URL}")"
    if [[ "${put_code}" == "201" || "${put_code}" == "200" ]]; then
      # Verify on destination after PUT
      if exists_on_node "${DST_URL}"; then
        echo "${LINE}" >> "${COPIED}"
        echo -e "${LINE}\t${SRC_NODE}\t${TARGET}\tok\t${put_code}" >> "${TSV}"
        log "OK (${put_code})"
        break
      fi
    fi
    log "RETRY NEEDED (last PUT code=${put_code})"
    sleep 1
  done

  # If still not present, mark as failed
  if ! exists_on_node "${DST_URL}"; then
    echo "${LINE}" >> "${FAILED}"
    echo -e "${LINE}\t${SRC_NODE}\t${TARGET}\tfail\t${put_code}" >> "${TSV}"
    log "FAILED (final PUT code=${put_code})"
  fi
done < "${UNION}"

# --------------------------------- Summary -----------------------------------
echo "Output: ${OUTDIR}"
echo "  union file            : ${UNION}"
echo "  summary (TSV)         : ${TSV}"
echo "  copied                : ${COPIED}                  ($(wc -l < "${COPIED}" 2>/dev/null || echo 0))"
echo "  skipped (exists)      : ${SKIPPED_EXISTS}          ($(wc -l < "${SKIPPED_EXISTS}" 2>/dev/null || echo 0))"
echo "  no source found       : ${NOT_FOUND_SRC}           ($(wc -l < "${NOT_FOUND_SRC}" 2>/dev/null || echo 0))"
echo "  failed                : ${FAILED}                  ($(wc -l < "${FAILED}" 2>/dev/null || echo 0))"
(( DRYRUN )) && echo "  would copy (dry-run)  : ${WOULD_COPY}              ($(wc -l < "${WOULD_COPY}" 2>/dev/null || echo 0))"
echo "  detailed log          : ${LOG}"
