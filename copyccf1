#!/bin/bash
# -----------------------------------------------------------------------------
# Copy HCP objects from any source node to a chosen target node (no overwrite).
# Supports DRY-RUN: reports what would be copied, but does NOT perform PUTs.
#
# Input lines in list files must be: <namespace>/<object-path>
# URL shape used: https://<ns>.<tenant>.<node>.<domain>/rest/<key>
# -----------------------------------------------------------------------------

set -euo pipefail

LISTS=""        # space-separated files with object paths, e.g. "hcp1.txt hcp2.txt ..."
TARGET=""       # target node alias, e.g. hcp4
NODES=""        # space-separated nodes, order used as probing priority for source
TENANT=""; DOMAIN=""; TOKEN=""
DEBUG=0; RETRIES=2; LIMIT=0; DRYRUN=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --lists)   LISTS="$2"; shift 2 ;;
    --target)  TARGET="$2"; shift 2 ;;
    --nodes)   NODES="$2"; shift 2 ;;
    --tenant)  TENANT="$2"; shift 2 ;;
    --domain)  DOMAIN="$2"; shift 2 ;;
    --token)   TOKEN="$2"; shift 2 ;;
    --retries) RETRIES="$2"; shift 2 ;;
    --limit)   LIMIT="$2"; shift 2 ;;
    --debug)   DEBUG=1; shift ;;
    --dry-run) DRYRUN=1; shift ;;
    -h|--help)
      cat <<EOF
Usage:
  $0 --lists "hcp1.txt hcp2.txt ..." --target hcpX --nodes "hcp1 hcp2 hcp3 hcp4" \\
     --tenant TENANT --domain DOMAIN --token TOKEN [--retries N] [--limit N] [--debug] [--dry-run]
Notes:
  - Token is RAW (no "Authorization: HCP " prefix).
  - In DRY-RUN, no PUT is executed; only classification and planning.
EOF
      exit 0 ;;
    *) echo "Unknown arg: $1" >&2; exit 1 ;;
  esac
done

[[ -n "${LISTS}" && -n "${TARGET}" && -n "${NODES}" && -n "${TENANT}" && -n "${DOMAIN}" && -n "${TOKEN}" ]] \
  || { echo "ERROR: required args missing" >&2; exit 1; }

for f in $LISTS; do
  [[ -f "$f" ]] || { echo "ERROR: list file not found: $f" >&2; exit 1; }
done

STAMP="$(date +%Y%m%d_%H%M%S)"
OUTDIR="output/${STAMP}_copy_to_${TARGET}"
mkdir -p "${OUTDIR}"

LOG="${OUTDIR}/copy.log"
TSV="${OUTDIR}/copy_summary.tsv"
SKIPPED_EXISTS="${OUTDIR}/skipped_exists.txt"
FAILED="${OUTDIR}/failed.txt"
COPIED="${OUTDIR}/copied.txt"
NOT_FOUND_SRC="${OUTDIR}/not_found_on_any_source.txt"
WOULD_COPY="${OUTDIR}/would_copy.txt"            # dry-run only
WOULD_FAIL="${OUTDIR}/would_fail.txt"            # dry-run only

: > "${LOG}"; : > "${TSV}"; : > "${SKIPPED_EXISTS}"
: > "${FAILED}"; : > "${COPIED}"; : > "${NOT_FOUND_SRC}"
: > "${WOULD_COPY}"; : > "${WOULD_FAIL}"

echo -e "path\tsource_node\ttarget_node\tresult\tinfo" > "${TSV}"

clean_line() { echo "$1" | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'; }

http_code() {
  local url="$1"
  curl -sk -o /dev/null -w '%{http_code}' -H "Authorization: HCP ${TOKEN}" "${url}" || echo "000"
}

exists_on_node() {
  local url="$1" code
  code="$(http_code "$url")"
  [[ "$code" =~ ^(200|204|206)$ ]]
}

copy_once() {
  local src_url="$1" dst_url="$2"
  curl -sk -H "Authorization: HCP ${TOKEN}" "${src_url}" \
  | curl -sk -X PUT -H "Authorization: HCP ${TOKEN}" -H "Content-Type: application/octet-stream" \
         --data-binary @- -w '%{http_code}' -o /dev/null "${dst_url}" || echo "000"
}

log() { printf "[%s] %s\n" "$(date '+%F %T')" "$*" >> "${LOG}"; }

# Build union of objects from list files
UNION="${OUTDIR}/objects_union.txt"; : > "${UNION}"
for f in $LISTS; do awk 'NF' "$f"; done \
  | sed -e 's/\r$//' -e 's/^[[:space:]]*//;s/[[:space:]]*$//' \
  | awk '!seen[$0]++' > "${UNION}"

TOTAL="$(wc -l < "${UNION}" | tr -d ' ')"
log "Union built: ${TOTAL} unique objects"
(( DEBUG )) && echo "Lists: ${LISTS}" >> "${LOG}"

i=0
while IFS= read -r raw || [[ -n "$raw" ]]; do
  LINE="$(clean_line "$raw")"
  [[ -z "${LINE}" ]] && continue
  (( i++ ))
  (( LIMIT > 0 && i > LIMIT )) && { log "Limit ${LIMIT} reached, stopping."; break; }

  NS="${LINE%%/*}"
  KEY="${LINE#*/}"

  # find first source node with the object
  SRC_NODE=""; SRC_URL=""
  for n in ${NODES}; do
    [[ "${n}" == "${TARGET}" ]] && continue
    url="https://${NS}.${TENANT}.${n}.${DOMAIN}/rest/${KEY}"
    if exists_on_node "${url}"; then
      SRC_NODE="${n}"; SRC_URL="${url}"; break
    fi
  done

  if [[ -z "${SRC_NODE}" ]]; then
    echo "${LINE}" >> "${NOT_FOUND_SRC}"
    echo -e "${LINE}\t-\t${TARGET}\tno-source\t404" >> "${TSV}"
    log "NO SOURCE for ${LINE}"
    continue
  fi

  DST_URL="https://${NS}.${TENANT}.${TARGET}.${DOMAIN}/rest/${KEY}"

  # already on target?
  if exists_on_node "${DST_URL}"; then
    echo "${LINE}" >> "${SKIPPED_EXISTS}"
    echo -e "${LINE}\t${SRC_NODE}\t${TARGET}\tskip-exists\t200" >> "${TSV}"
    log "EXISTS on target, skip: ${LINE} (src ${SRC_NODE})"
    continue
  fi

  if (( DRYRUN )); then
    echo "${LINE}" >> "${WOULD_COPY}"
    echo -e "${LINE}\t${SRC_NODE}\t${TARGET}\tdry-run\twould-copy" >> "${TSV}"
    log "DRY-RUN would copy: ${SRC_NODE} -> ${TARGET} | ${LINE}"
    continue
  fi

  # real copy with retries
  attempt=0; put_code="000"
  while (( attempt <= RETRIES )); do
    (( attempt++ ))
    log "COPY attempt ${attempt}: ${SRC_NODE} -> ${TARGET} | ${LINE}"
    put_code="$(copy_once "${SRC_URL}" "${DST_URL}")"
    if [[ "${put_code}" == "201" || "${put_code}" == "200" ]]; then
      if exists_on_node "${DST_URL}"; then
        echo "${LINE}" >> "${COPIED}"
        echo -e "${LINE}\t${SRC_NODE}\t${TARGET}\tok\t${put_code}" >> "${TSV}"
        log "OK (${put_code}) ${LINE}"
        break
      fi
    fi
    log "RETRY (${put_code}) ${LINE}"
    sleep 1
  done

  if ! exists_on_node "${DST_URL}"; then
    echo "${LINE}" >> "${FAILED}"
    echo -e "${LINE}\t${SRC_NODE}\t${TARGET}\tfail\t${put_code}" >> "${TSV}"
    log "FAILED (${put_code}) ${LINE}"
  fi
done < "${UNION}"

echo "Output: ${OUTDIR}"
echo "  union               : ${UNION}"
echo "  summary TSV         : ${TSV}"
echo "  skipped (exists)    : ${SKIPPED_EXISTS}  ($(wc -l < "${SKIPPED_EXISTS}" 2>/dev/null || echo 0))"
echo "  no source found     : ${NOT_FOUND_SRC}   ($(wc -l < "${NOT_FOUND_SRC}" 2>/dev/null || echo 0))"
if (( DRYRUN )); then
  echo "  would copy          : ${WOULD_COPY}      ($(wc -l < "${WOULD_COPY}" 2>/dev/null || echo 0))"
  echo "  would fail (n/a)    : ${WOULD_FAIL}      ($(wc -l < "${WOULD_FAIL}" 2>/dev/null || echo 0))"
else
  echo "  copied              : ${COPIED}          ($(wc -l < "${COPIED}" 2>/dev/null || echo 0))"
  echo "  failed              : ${FAILED}          ($(wc -l < "${FAILED}" 2>/dev/null || echo 0))"
fi
echo "  log                 : ${LOG}"